// Package hostname provides a utility method to generate a hostname which can
// be used in conjunction with the stateless DNS server
// https://github.com/taskcluster/stateless-dns-server
//
// Domains generated by this library encode an IP-address, expiration date, a
// random salt and an HMAC-SHA256 signature truncated to 128 bits.
//
// This provides a mechanism to assign temporary sub-domains names to nodes
// with a public IP-address. The same problem can also be solved with dynamic
// DNS server, but such entries often requires clean-up. The beauty of this
// approach is that the DNS server is state-less, so there is no stale DNS
// records to discard.
//
// In TaskCluster this is used to assign temporary sub-domain names to EC2 spot
// nodes, such that we can host HTTPS resources, such as live logs, without
// updating and cleaning up the state of the DNS server.
//
// Notice, that with IP-address, expiration date, random salt and HMAC-SHA256
// signature encoded in the sub-domain label, you cannot decide which
// sub-domain label you wish to have. Hence, this is only useful in cases were
// the hostname for your node is transmitted to clients by other means, for
// example in a message over RabbitMQ or as temporary entry in a database.
// Further more, to serve HTTPS content you'll need a wild-card SSL
// certificate, for domain managed by this DNS server.
//
// Note, this obviously doesn't have many applications, as the sub-domain label
// is stateful. It's mostly for serving HTTPS content from nodes that come and
// go quickly with minimal setup, where the hostname is transmitted by other
// means.  Generally, any case where you might consider using the default EC2
// hostname.
//
// Sub-domain Label Generation
//
// The sub-domain label encodes the following parameters:
//
//  * `ip`, address to which the `A` record returned should point,
//  * `expires`, expiration of sub-domain as number of ms since epoch,
//  * `salt`, random salt, allowing for generation of multiple sub-domain
//    labels for each IP-address, and,
//  * `signature`, HMAC-SHA256 signature of `ip`, `expires` and `salt` truncated
//    to 128 bit.
//
// The `expires` property is encoded as a big-endian 64 bit signed integer. The
// `salt` property is encoded as bit-endian 16 bit unsigned integer. All
// properties are concatenated and base32 (RFC 3548) encoded to form the
// sub-domain label.
package hostname

import (
	"bytes"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base32"
	"encoding/binary"
	"net"
	"strings"
	"time"
)

// New generates a temporary hostname for the given ip, with the given
// subdomain, having the given expiry, using the given secret.
func New(ip net.IP, subdomain string, expires time.Time, secret string) (string, error) {
	buf := new(bytes.Buffer)
	ip4 := []byte(ip.To4())
	_, err := buf.Write(ip4)
	if err != nil {
		return "", err
	}
	expiryInUnixMillis := int64(expires.UnixNano() / 1000)
	err = binary.Write(buf, binary.BigEndian, expiryInUnixMillis)
	if err != nil {
		return "", err
	}
	salt := make([]byte, 2)
	_, err = rand.Read(salt)
	if err != nil {
		return "", err
	}
	_, err = buf.Write(salt)
	if err != nil {
		return "", err
	}
	hash := hmac.New(sha256.New, []byte(secret))
	content := buf.Bytes()
	_, err = hash.Write(content)
	if err != nil {
		return "", err
	}
	signature := hash.Sum([]byte{})[:16]
	result := append(content, signature...)
	label := base32.StdEncoding.EncodeToString(result)
	return strings.ToLower(label + "." + subdomain), nil
}
